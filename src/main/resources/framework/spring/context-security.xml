<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:security="http://www.springframework.org/schema/security"
	   xmlns:oauth="http://www.springframework.org/schema/security/oauth2"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
	                       http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd
	                       http://www.springframework.org/schema/security/oauth2 http://www.springframework.org/schema/security/spring-security-oauth2.xsd">


    <!-- http pattern을 이렇게 별도로 설정하면 해당 패턴에 대해 security filter chain을 거치치 않는다(bypass)  -->
 	<security:http pattern="/resources/**" security="none"/>
 	<security:http pattern="/signup.do"    security="none"/> <!-- signup -->
 	<security:http pattern="/error.jsp"    security="none"/>
 	<security:http pattern="/"             security="none"/>

    <!-- Enables Spring Security -->
    <!-- web.xml에 설정된 DelegatingFilterProxy필터가 Spring Security의 필터를 차례로 통과하도록 한다 -->
    <security:http use-expressions="true" entry-point-ref="authenticationEntryPoint">
        <security:intercept-url pattern="/**" access="isAuthenticated()" />
		<security:logout success-handler-ref="successLogoutHandler" />
		<!-- <security:csrf disabled="true" /> -->
		<security:anonymous enabled="false" />

		<!-- 필터에 의해 인증 예외가 발생하면 인증서버의 로그인 페이지로 redirect되어야 한다. -->
		<security:custom-filter ref="oauth2ClientFilter" after="EXCEPTION_TRANSLATION_FILTER" />
		<!-- 인증서버로 부터 리턴받은 Access Token의 정보를 SecurityContext에 전달하는 필터 -->
		<security:custom-filter ref="oauth2AuthenticationProcessingFilter" before="FILTER_SECURITY_INTERCEPTOR" />
    </security:http>

    <bean id="authenticationEntryPoint" class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">
	    <constructor-arg index="0" value="${oauth2.filterCallbackPath}" />
	</bean>

    <!-- security filter chain에 OAuth2ClientContextFilter 추가 -->
    <oauth:client id="oauth2ClientFilter" />

    <!-- OAuth2ProtectedResourceDetails -->
    <oauth:resource
        id="google"
		client-id="${oauth2.clientId}"
		client-secret="${oauth2.clientSecret}"
		access-token-uri="${oauth2.accessTokenUri}"
		user-authorization-uri="${oauth2.userAuthorizationUri}"
		scope="${oauth2.scope}"
		type="authorization_code"
		client-authentication-scheme="form"/>


    <!-- An OAuth2 client filter that can be used to acquire an OAuth2 access token
         from an authorization server, and load an authentication object into the SecurityContext -->
    <bean id="oauth2AuthenticationProcessingFilter" class="org.springframework.security.oauth2.client.filter.OAuth2ClientAuthenticationProcessingFilter">
        <!-- This should match whatever you have configured in the login entry point above -->
        <constructor-arg name="defaultFilterProcessesUrl" value="${oauth2.filterCallbackPath}"/>
        <property name="restTemplate" ref="restTemplate"/>
        <property name="tokenServices" ref="tokenServices"/>
        <property name="authenticationSuccessHandler" ref="authenticationSuccessHandler"/>
    </bean>

    <!--
    <bean id="restTemplate" class="org.springframework.security.oauth2.client.OAuth2RestTemplate">
        <constructor-arg name="resource" ref="google"/>
    </bean>
    -->
    <!-- oauth 네임스페이스를 사용해야 oauth2ClientFilter의 oauth2ClientContext를 사용할 수 있다 -->
    <oauth:rest-template id="restTemplate" resource="google"/>

    <!-- 인증서버로부터 받은 토큰을 검사하고 사용자 정보를 획득 -->
    <bean id="tokenServices" class="com.foo.myapp.common.security.oauth2.GoogleTokenServices">
        <property name="checkTokenEndpointUrl" value="${oauth2.tokenInfoUri}"/>
        <property name="clientId" value="${oauth2.clientId}"/>
        <property name="clientSecret" value="${oauth2.clientSecret}"/>
        <property name="accessTokenConverter" ref="accessTokenConverter" />
    </bean>

    <bean id="accessTokenConverter" class="com.foo.myapp.common.security.oauth2.GoogleAccessTokenConverter">
        <property name="userTokenConverter">
            <bean class="com.foo.myapp.common.security.oauth2.DefaultUserAuthenticationConverter"/>
        </property>
    </bean>

    <bean id="successLogoutHandler" class="com.foo.myapp.common.security.oauth2.GoogleSuccessLogoutHandler" />

    <bean id="authenticationSuccessHandler" class="com.foo.myapp.common.security.oauth2.CustomAuthenticationSuccessHandler" />


    <!-- in-memory authentication for simple test -->
    <!-- authenticationManager가 없으면 No bean named 'org.springframework.security.authenticationManager' is defined 오류 -->
    <!-- form-login을 사용하지 않을 것이므로 여기에 적은 사용자 계정은 의미가 없다 -->
    <security:authentication-manager alias="authenticationManager">
	    <security:authentication-provider>
	        <security:user-service>
	            <security:user name="scott" password="tiger" authorities="ROLE_USER" />
	        </security:user-service>
	    </security:authentication-provider>
    </security:authentication-manager>



</beans>
